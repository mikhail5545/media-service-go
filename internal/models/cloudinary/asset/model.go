package asset

import (
	"time"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

type Status string

const (
	StatusUploadURLGenerated Status = "upload_url_generated"
	StatusActive             Status = "active"
	StatusArchived           Status = "archived"
	StatusBroken             Status = "broken"
)

type Asset struct {
	ID        uuid.UUID      `gorm:"primaryKey;type:uuid" json:"id"` // UUIDv7
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	DeletedAt gorm.DeletedAt `gorm:"index" json:"deleted_at"`

	Status Status `gorm:"type:varchar(32);default:'active'" json:"status"`

	CloudinaryAssetID  string   `gorm:"not null;uniqueIndex" json:"cloudinary_asset_id"` // External ID (Cloudinary ID), parsed from webhooks
	URL                string   `gorm:"uniqueIndex" json:"url"`
	SecureURL          string   `gorm:"uniqueIndex" json:"secure_url"`
	CloudinaryPublicID string   `gorm:"type:varchar(512);not null;uniqueIndex" json:"cloudinary_public_id"` // External ID (Cloudinary public ID for asset), used in most of Cloudinary API interactions
	ResourceType       string   `gorm:"type:varchar(128)" json:"resource_type"`
	Format             string   `gorm:"type:varchar(32)" json:"format"`   // Asset format (png, jpeg, jpc, etc.), parsed from webhooks
	Width              *int     `gorm:"null" json:"width"`                // Width for images, parsed from webhooks
	Height             *int     `gorm:"null" json:"height"`               // Height for images, parsed from webhooks
	Tags               []string `gorm:"type:varchar(128)[]" json:"tags"`  // Tags, generated by Cloudinary
	AssetFolder        string   `gorm:"varchar(128)" json:"asset_folder"` // Asset folder in the Cloudinary, parsed from webhooks
	DisplayName        string   `gorm:"varchar(255)" json:"display_name"` // Asset's display name, parsed from webhooks

	Note          *string `gorm:"type:varchar(512);null" json:"note"`           // Optional note about the asset
	ArchiveReason *string `gorm:"type:varchar(512);null" json:"archive_reason"` // Optional reason for archiving the asset

	CreatedBy        *uuid.UUID `gorm:"type:uuid;null" json:"created_by"`          // Admin ID who created the asset
	ArchivedBy       *uuid.UUID `gorm:"type:uuid;null" json:"archived_by"`         // Admin ID who archived the asset
	MarkedAsBrokenBy *uuid.UUID `gorm:"type:uuid;null" json:"marked_as_broken_by"` // Admin ID who marked the asset as broken
	RestoredBy       *uuid.UUID `gorm:"type:uuid;null" json:"restored_by"`         // Admin ID who restored the asset

	CreatedByName        *string `gorm:"type:varchar(128);null" json:"created_by_name"`          // Admin name who created the asset
	ArchivedByName       *string `gorm:"type:varchar(128);null" json:"archived_by_name"`         // Admin name who archived the asset
	MarkedAsBrokenByName *string `gorm:"type:varchar(128);null" json:"marked_as_broken_by_name"` // Admin name who marked the asset as broken
	RestoredByName       *string `gorm:"type:varchar(128);null" json:"restored_by_name"`         // Admin name who restored the asset

	ArchiveNotificationContextID *string `gorm:"type:varchar(256);null" json:"archive_notification_context_id"` // Notification context ID from webhook when asset was archived
}

func (*Asset) TableName() string {
	return "cloudinary_assets"
}

func (a *Asset) BeforeCreate(tx *gorm.DB) (err error) {
	if a.ID == uuid.Nil {
		a.ID, err = uuid.NewV7()
		if err != nil {
			return err
		}
	}
	return nil
}
